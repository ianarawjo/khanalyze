(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") return mod(exports); // CommonJS
  if (typeof define == "function" && define.amd) return define(["exports"], mod); // AMD
  mod(root.khanalyze || (root.khanalyze = {})); // Plain browser env (this === window)
})(this, function(exports) {

  /* JS code analysis 

    Khanalyze public methods:
      .setParser(parser, options) ---  Sets parser (see method for more info)
      .setCheck(name, template)   ---  Add or update a check to be performed during .test.
      .removeCheck(name)
      .removeAllChecks()
      .test(code)                 ---  Gives feedback on code per each 'check'.

    For checks, template can be one of:
      typename    ----    ex. 'ForStatement'
      [typename]  ----    ex. ['IfStatement', 'VariableDeclaration']
      ast         ----    ex. { type:'ForStatement' } (this is equivalent to the first example)
      [ast]       ----    ex. [{ type:'IfStatement' }, { type:'VariableDeclaration' }] (same as 2nd example)

    Thus the code analyzer can take another AST as a template. Because of the
    large number of cases, this functionality is not completely guaranteed
    for more complex ASTs.

    Sample use case:

    |  khanalyze.addCheck('whitelist', 'ForStatement');
    |  var feedback = khanalyze.test(code);
    |  if (feedback !== null) {
    |    var r = feedback['whitelist'];
    |    // do something here...
    |  }

    Feedback is given as a dictionary mapping checks to results in the form of 'markup'. 
    Markup has the following properties:
      .included --- returns array of code snippets per each matched template element
      .missing  --- returns array of unmatched template elements

    So if you setCheck('whitelist', ['IfStatement', 'ForStatement']), 
    and test('if(true) {}'), you'll get:

    |  feedback['whitelist'].included = [{ raw:'IfStatement', start:Position, end:Position }]
    |  feedback['whitelist'].missing  = ['ForStatement']

    where Position is as specified in Mozilla's Parser API:
    https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API
      interface Position {
        line: uint32 >= 1;
        column: uint32 >= 0;
      }

    Note that if you want Position information, you must
    specify the location option when you set the parser.
    For acorn, that would be:
    |  khanalyze.setParser(acorn, { location:true });
    
  */

  // List of checks. E.g. stores whitelist, blacklist etc.
  var checks = {};

  // The parser to use
  var parser = null;
  var options = null;

  // Set check named 'ck' to list of checks
  // * Automatically adds 'ck' if it's not in checks.
  exports.setCheck = function(ck, template) {
    if (typeof ck === 'string')
      checks[ck] = template;
    else
      console.log("Skipping: khanalyze.setList: List name is not a string.");
  };
  exports.removeCheck = function(ck) {
    if (checks.hasOwnProperty(ck))
      delete checks[ck];
    // otherwise do nothing
  };
  exports.removeAllChecks = function() {
    checks = {};
  };

  // Set parser
  //  |  A parser is an object with a function .parse(code, options) => ast,
  //  |  where ast is a Javascript AST generated by acorn, esprima etc that follows Mozilla's Parser API:
  //  |  https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API
  // 
  // * If you want code snippets to included .start and .end line information,
  // * then you must set the options of your respective parser to include locations.
  exports.setParser = function(p, opts) {
    parser = p;
    options = opts;
  };

  // Test
  // - Returns markup (see below) key-mapped to each check.
  // - Returns null if code can't be parsed.
  exports.test = function(code) {

    if (parser === null) {
      console.log("Error: khanalyze: No parser set.");
      return null;
    }

    // First try to parse code. 
    var ast;
    try {
      ast = parser.parse(code, options);
    } catch(e) {
      // code couldn't be parsed
      return null;
    }

    // Stores results of each check, key-mapped to check name.
    var feedback = {};

    // For each check, test code AST against that check's template:
    var template;
    for (var ck in checks) {
      if (checks.hasOwnProperty(ck)) {

        template = checks[ck];

        // Skip trivial cases
        if(template === null || (template instanceof Array && template.length === 0)) {
          feedback[ck] = null;
          continue;
        }

        // Compare AST to template, storing result as markup
        feedback[ck] = analyze(ast, checks[ck]);
      }
    }

    return feedback;
  };

  // === PRIVATE METHODS ===

  // Container for result of code analysis
  // * Takes array of code snippets for .included,
  // * and array of remaining inputs as .missing
  var markup = function(included_snippets, leftover_input) {
    return {
      included: included_snippets,
      missing: leftover_input
    };
  };

  // Container for a code snippet, in 
  // similar interface to SourceLocation:
  //
  // interface snippet {
  //  raw: string | object  // the original input (could be forgetful AST)
  //  start: Position | null; // the positions of the source code in line,column format.
  //  end: Position | null;
  // }
  //
  // * see https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API *
  var snippet = function(input, start, end) {
    return {
      raw: input,
      start: start,
      end: end
    };
  };

  // Analyze
  // | Takes AST and template, returns feedback
  // | in the form of markup (see above).
  var analyze = function(ast, template) {
    return forgetfulMatch(ast, template);
  };

  // The forgetful matcher walks the AST tree 
  // checking that properties defined in the templateAST
  // match corresponding properties in the AST, 'forgetting'
  // the extra structure that the AST may provide. 
  // * Returns markup (see above).
  // -----------------------------
  // | For instance, given the template { type:'ForStatement' }, 
  // | this function just recurses through the code's AST looking 
  // | for an object with the type 'ForStatement' -- 
  // | it doesn't care about any other properties of the ForStatement
  // | unless they were specified in the template.
	var forgetfulMatch = function(node, templateAST) {
    var mark = markup([], []);
    var finalresult = true;
    var orig_template;
    var line_info;

    // -- Prepare template --
    // If template is not an array, turn it into one,
    // so that we can treat all inputs the same.
    if ((templateAST instanceof Array) === false)
      templateAST = [ templateAST ];

    // Make shallow copy of array
    templateAST = templateAST.slice(0);

    // Store original version of template
    orig_template = templateAST.slice(0);

    // Check whether any template elements are strings.
    for(var i = 0; i < templateAST.length; i++) {
      if (typeof templateAST[i] === "string") {
        templateAST[i] = { type: templateAST[i] }; // turn strings into objects
      }
    }

		// Looks for JSON which matches 'structure' inside AST.
    // * Parameters: AST, visitorNode, compare_properties function.
		function match(A, V, c) {

			// Compare literals
			if (A === V) {
				
        // Matching literals
				return true;
			}
			else if (A instanceof Array) { // If A is an array, compare visitor V against all elements in A

        // Treat V as array
        if (V instanceof Array === false)
          V = [ V ];

        // Trivial cases
        // | Elements of A only have to match the
        // | (unordered) elements of V, for all elements
        // | of V. So if V has more elements of A, A cannot
        // | possibly fulfill V and we return false.
        // | If V has zero elements, the result is vacuously true.
				if (V.length > A.length) return false;
				if (V.length === 0) return true;

        // Compare all elements of array
				var i = 0, j = 0, r = false;
				var result = true;
				for (; i < V.length; i++) { // loop over visitors.
          j = 0;
          r = false;

          // Compare V[i] to all elements in A.
          for (; j < A.length; j++) {

            // Try to match elements.
            r = match(A[j], V[i], c);

            if (r === true) // If one of the elements of A matches element i of the template array...
              break; // break and continue to next case
          }

          // Arrays are unequal if one element of the template array != any object in A...
          result = r && result;
          if (result === false) break;
        }
        
        // Return whether arrays are 'equal'
        return result;
      }
      else if (A instanceof Object && V instanceof Object) {

        // Compare inner objects by comparing their properties
        return c(A, V, null);
      }
      else {

        // Mismatch
        return false;
      }
    }

    // Compare properties of two objects, node and visitor. (recursive)
		function compare_properties(node, visitor, override) {
			var type = override || node.type;
			var cresult = false;

			// Only perform comparison when node type matches visitor node type
			if (visitor["type"] === type) {
				visitorTypeInNode = true;
				cresult = true;

        // Compare properties of same-type objects:
				for (var property in visitor) {
					if (visitor.hasOwnProperty(property)) {
						if (property === "type" || property === "start" || property === "end" || property === "loc") {
							continue; // we don't care about these properties...
						}
						else if (node.hasOwnProperty(property)) {
							
              // Determine whether properties match
							cresult = match(node[property], visitor[property], compare_properties) && cresult;
						}
						else {
							
              // Visitor property is not in this node. 
              // Templates don't match -- cascade false up the call stack.
							cresult = false;
						}
          }

          // Quit if one property doesn't match
          if (cresult === false)
            break;
				}
				
        // Append line position info for a correct match
        if (cresult === true && node.loc) {
          line_info = snippet(null, node.loc.start, node.loc.end);
        }

				finalresult = finalresult || cresult;
			}
			else if (visitor["type"] === "Wildcard") {
				return true;
			}
			else {
        
        // Recurse into node if types don't match. 
        // Compare visitor to all subnodes.
        base[type](node, visitor, compare_properties);
			}

      // Return whether properties were equal. 
      // * (irrelevant unless called within match method) *
			return cresult;
		}

    // Try to match all elements in template to AST
		var arraymux = true;
    var k = 0;
		for (; k < templateAST.length; k++) {

      // 'finalresult' acts like a global in this scope,
      // containing the result of the test.
			finalresult = false;

      // Compare template k to AST
			compare_properties(node, templateAST[k], null);

      // Generate markup from result
      if (finalresult === true) {
        line_info.raw = orig_template[k];
        mark.included.push(line_info);
      } else
        mark.missing.push(orig_template[k]);

		}

		return mark;
  };


  // Node walkers required for the walk.
  // * Copied from acorn.js's walk example code. *
  // This acorn license applies to the code below:
  /*

      Copyright (C) 2012-2014 by various contributors:
      See https://github.com/marijnh/acorn/blob/master/AUTHORS.

      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:

      The above copyright notice and this permission notice shall be included in
      all copies or substantial portions of the Software.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
      THE SOFTWARE.

  */
  function skipThrough(node, st, c) { c(node, st); }
  function ignore(_node, _st, _c) {}
  var base = exports.base = {};
  base.Program = base.BlockStatement = function(node, st, c) {
    for (var i = 0; i < node.body.length; ++i) {
      c(node.body[i], st, "Statement");
    }
  };
  base.Statement = skipThrough;
  base.EmptyStatement = ignore;
  base.ExpressionStatement = function(node, st, c) {
    c(node.expression, st, "Expression");
  };
  base.IfStatement = function(node, st, c) {
    c(node.test, st, "Expression");
    c(node.consequent, st, "Statement");
    if (node.alternate) c(node.alternate, st, "Statement");
  };
  base.LabeledStatement = function(node, st, c) {
    c(node.body, st, "Statement");
  };
  base.BreakStatement = base.ContinueStatement = ignore;
  base.WithStatement = function(node, st, c) {
    c(node.object, st, "Expression");
    c(node.body, st, "Statement");
  };
  base.SwitchStatement = function(node, st, c) {
    c(node.discriminant, st, "Expression");
    for (var i = 0; i < node.cases.length; ++i) {
      var cs = node.cases[i];
      if (cs.test) c(cs.test, st, "Expression");
      for (var j = 0; j < cs.consequent.length; ++j)
        c(cs.consequent[j], st, "Statement");
    }
  };
  base.ReturnStatement = base.YieldExpression = function(node, st, c) {
    if (node.argument) c(node.argument, st, "Expression");
  };
  base.ThrowStatement = base.SpreadElement = function(node, st, c) {
    c(node.argument, st, "Expression");
  };
  base.TryStatement = function(node, st, c) {
    c(node.block, st, "Statement");
    if (node.handler) c(node.handler.body, st, "ScopeBody");
    if (node.finalizer) c(node.finalizer, st, "Statement");
  };
  base.WhileStatement = function(node, st, c) {
    c(node.test, st, "Expression");
    c(node.body, st, "Statement");
  };
  base.DoWhileStatement = base.WhileStatement;
  base.ForStatement = function(node, st, c) {
    if (node.init) c(node.init, st, "ForInit");
    if (node.test) c(node.test, st, "Expression");
    if (node.update) c(node.update, st, "Expression");
    c(node.body, st, "Statement");
  };
  base.ForInStatement = base.ForOfStatement = function(node, st, c) {
    c(node.left, st, "ForInit");
    c(node.right, st, "Expression");
    c(node.body, st, "Statement");
  };
  base.ForInit = function(node, st, c) {
    if (node.type == "VariableDeclaration") c(node, st);
    else c(node, st, "Expression");
  };
  base.DebuggerStatement = ignore;

  base.FunctionDeclaration = function(node, st, c) {
    c(node, st, "Function");
  };
  base.VariableDeclaration = function(node, st, c) {
    for (var i = 0; i < node.declarations.length; ++i) {
      var decl = node.declarations[i];
      if (decl.init) c(decl.init, st, "Expression");
    }
  };

  base.Function = function(node, st, c) {
    c(node.body, st, "ScopeBody");
  };
  base.ScopeBody = function(node, st, c) {
    c(node, st, "Statement");
  };

  base.Expression = skipThrough;
  base.ThisExpression = ignore;
  base.ArrayExpression = function(node, st, c) {
    for (var i = 0; i < node.elements.length; ++i) {
      var elt = node.elements[i];
      if (elt) c(elt, st, "Expression");
    }
  };
  base.ObjectExpression = function(node, st, c) {
    for (var i = 0; i < node.properties.length; ++i)
      c(node.properties[i], st);
  };
  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
  base.SequenceExpression = base.TemplateLiteral = function(node, st, c) {
    for (var i = 0; i < node.expressions.length; ++i)
      c(node.expressions[i], st, "Expression");
  };
  base.UnaryExpression = base.UpdateExpression = function(node, st, c) {
    c(node.argument, st, "Expression");
  };
  base.BinaryExpression = base.AssignmentExpression = base.LogicalExpression = function(node, st, c) {
    c(node.left, st, "Expression");
    c(node.right, st, "Expression");
  };
  base.ConditionalExpression = function(node, st, c) {
    c(node.test, st, "Expression");
    c(node.consequent, st, "Expression");
    c(node.alternate, st, "Expression");
  };
  base.NewExpression = base.CallExpression = function(node, st, c) {
    c(node.callee, st, "Expression");
    if (node.arguments) for (var i = 0; i < node.arguments.length; ++i)
      c(node.arguments[i], st, "Expression");
  };
  base.MemberExpression = function(node, st, c) {
    c(node.object, st, "Expression");
    if (node.computed) c(node.property, st, "Expression");
  };
  base.Identifier = base.Literal = base.ExportDeclaration = base.ImportDeclaration = ignore;

  base.TaggedTemplateExpression = function(node, st, c) {
    c(node.tag, st, "Expression");
    c(node.quasi, st);
  };
  base.ClassDeclaration = base.ClassExpression = function(node, st, c) {
    if (node.superClass) c(node.superClass, st, "Expression");
    for (var i = 0; i < node.body.body.length; i++)
      c(node.body.body[i], st);
  };
  base.MethodDefinition = base.Property = function(node, st, c) {
    if (node.computed) c(node.key, st, "Expression");
    c(node.value, st, "Expression");
  };
  base.ComprehensionExpression = function(node, st, c) {
    for (var i = 0; i < node.blocks.length; i++)
      c(node.blocks[i].right, st, "Expression");
    c(node.body, st, "Expression");
  };

});